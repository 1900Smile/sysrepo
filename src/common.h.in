/**
 * @file common.h
 * @author Michal Vasko <mvasko@cesnet.cz>
 * @brief common routines header
 *
 * @copyright
 * Copyright (c) 2019 CESNET, z.s.p.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef _COMMON_H
#define _COMMON_H

#define _GNU_SOURCE
#define _POSIX_C_SOURCE 200809L

#include <stdint.h>
#include <string.h>
#include <errno.h>

#include <libyang/libyang.h>

#include "sysrepo.h"

/*
 * If the compiler supports attribute to mark objects as hidden, mark all
 * objects as hidden and export only objects explicitly marked to be part of
 * the public API.
 */
#define API __attribute__((visibility("default")))

#define SR_YANG_MOD "sysrepo"
#define SR_REPO_PATH "@REPO_PATH@"
#define SR_REPO_PATH_ENV "SYSREPO_REPOSITORY_PATH"

/* s */
#define SR_MODULE_LOCK_TIMEOUT 5

/* s */
#define SR_SUBSCR_JOIN_TIMEOUT 5

/* ms */
#define SR_LOCK_TIMEOUT 100

/* ms */
#define SR_SUB_EVENT_STEP_TIMEOUT 20

/* number of */
#define SR_SUB_EVENT_STEP_COUNT 500

/* internal declarations + definitions
 */
#define MOD_INFO_DEP     0x01 /* dependency module, its data cannot be changed, but are required for validation */
#define MOD_INFO_INV_DEP 0x02 /* inverse dependency module, its data cannot be changed, but will be validated */
#define MOD_INFO_REQ     0x04 /* required module, its data can be changed and it will be validated */
#define MOD_INFO_TYPE_MASK 0x07 /* just a mask for all module types */

#define MOD_INFO_LOCK    0x08 /* locked module */
#define MOD_INFO_CHANGED 0x10 /* module data were changed */

typedef struct sr_mod_s sr_mod_t;

typedef struct sr_shm_s {
    int fd;
    size_t size;
    char *addr;
} sr_shm_t;

struct sr_mod_info_s {
    sr_datastore_t ds;
    struct lyd_node *diff;
    int dflt_change;
    sr_conn_ctx_t *conn;

    struct sr_mod_info_mod_s {
        sr_mod_t *shm_mod;
        uint8_t state;
        const struct lys_module *ly_mod;
        struct lyd_node *mod_data;
        uint32_t event_id;

        sr_shm_t conf_sub;
    } *mods;
    uint32_t mod_count;
};

#include "edit_diff.h"
#include "shm.h"
#include "log.h"

/* public definitions
 */
struct sr_conn_ctx_s {
    char *app_name;
    struct ly_ctx *ly_ctx;

    pthread_mutex_t ptr_lock;
    sr_session_ctx_t **sessions;
    uint32_t session_count;
    sr_subscription_ctx_t **subscriptions;
    uint32_t subscription_count;

    int main_plock;
    pthread_rwlock_t main_tlock;
    uint32_t main_ver;
    sr_shm_t main_shm;
};

struct sr_session_ctx_s {
    sr_conn_ctx_t *conn;
    sr_datastore_t ds;
    sr_notif_event_t ev;
    uint8_t flags;
    sr_error_info_t *err_info;

    struct {
        struct lyd_node *edit;
        struct lyd_node *diff;
    } dt[SR_DS_COUNT];
};

struct sr_subscription_ctx_s {
    sr_conn_ctx_t *conn;
    volatile pthread_t tid;

    struct modsub_conf_s {
        char *module_name;
        sr_datastore_t ds;
        struct modsub_confsub_s {
            sr_module_change_cb cb;
            void *private_data;
            char *xpath;
            uint32_t priority;
            sr_subscr_options_t opts;

            uint32_t event_id;
            sr_notif_event_t event;
        } *subs;
        uint32_t sub_count;

        struct lyd_node *diff;
        sr_shm_t sub_shm;
    } *conf_subs;
    uint32_t conf_sub_count;

    struct modsub_dp_s {
        char *module_name;
        struct modsub_dpsub_s {
            sr_dp_get_items_cb cb;
            void *private_data;
            char *xpath;

            uint32_t event_id;
            sr_shm_t sub_shm;
        } *subs;
        uint32_t sub_count;
    } *dp_subs;
    uint32_t dp_sub_count;
};

struct sr_change_iter_s {
    struct ly_set *set;
    uint32_t idx;
    int reverse_changes;
};

/*
 * subscription functions
 */
sr_error_info_t *sr_sub_conf_add(sr_conn_ctx_t *conn, const char *mod_name, const char *xpath, sr_datastore_t ds,
        sr_module_change_cb conf_cb, void *private_data, uint32_t priority, sr_subscr_options_t opts, sr_subscription_ctx_t **subs_p);

sr_error_info_t *sr_sub_dp_add(sr_conn_ctx_t *conn, const char *mod_name, const char *xpath, sr_dp_get_items_cb dp_cb,
        void *private_data, sr_subscription_ctx_t **subs_p);

sr_error_info_t *sr_sub_del_all(sr_conn_ctx_t *conn, sr_subscription_ctx_t *subs);

/*
 * utility functions
 */
/* if new_shm_size == 0 needs READ lock, otherwise needs WRITE lock! */
sr_error_info_t *sr_shm_remap(sr_shm_t *shm, size_t new_shm_size);

void sr_shm_destroy(sr_shm_t *shm);

sr_error_info_t *sr_lock(pthread_rwlock_t *rwlock, int wr, const char *func);

void sr_unlock(pthread_rwlock_t *rwlock);

void *sr_realloc(void *ptr, size_t size);

const char *sr_get_repo_path(void);

sr_error_info_t *sr_mkpath(char *file_path, mode_t mode, uint32_t start_idx);

/* buf must be size at least 22 */
char *sr_val_sr2ly_str(struct ly_ctx *ctx, const sr_val_t *value, char *buf);

char *sr_get_first_ns(const char *expr);

const char *sr_ds2str(sr_datastore_t ds);

sr_error_info_t *sr_msleep(uint32_t msec);

sr_error_info_t *sr_file_get_size(int fd, size_t *size);

const char *sr_ly_leaf_value_str(const struct lyd_node *leaf);

sr_error_info_t *sr_shared_rwlock_init(pthread_rwlock_t *rwlock);

const char *sr_ev2str(sr_notif_event_t ev);

sr_error_info_t *sr_val_ly2sr(const struct lyd_node *node, sr_val_t *sr_val);

sr_error_info_t *sr_val_sr2ly(const sr_val_t *sr_val, struct lyd_node **node);

void sr_ly_split(struct lyd_node *sibling);

void sr_ly_link(struct lyd_node *first, struct lyd_node *sibling);

int sr_ly_is_userord(const struct lyd_node *node);

sr_error_info_t *sr_ly_data_dup_filter(const struct lyd_node *data, char **xpaths, uint16_t xp_count,
        struct lyd_node **filter_data);

uint32_t sr_str_hash(const char *str);

sr_error_info_t *sr_ly_xpath_trim_last_node(const char *xpath, char **trim_xpath, char **last_node_xpath);

size_t sr_xpath_len_no_predicates(const char *xpath);

sr_error_info_t *sr_ly_dp_last_parent(struct lyd_node **parent);

#endif
