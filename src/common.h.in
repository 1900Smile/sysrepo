/**
 * @file common.h
 * @author Michal Vasko <mvasko@cesnet.cz>
 * @brief common routines header
 *
 * @copyright
 * Copyright (c) 2019 CESNET, z.s.p.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef _COMMON_H
#define _COMMON_H

#define _GNU_SOURCE
#define _POSIX_C_SOURCE 200809L

#include <stdint.h>
#include <string.h>
#include <errno.h>

#include <libyang/libyang.h>

#include "sysrepo.h"

/*
 * If the compiler supports attribute to mark objects as hidden, mark all
 * objects as hidden and export only objects explicitly marked to be part of
 * the public API.
 */
#define API __attribute__((visibility("default")))

/* use access() if eaccess() is not available (it may adversely affect access control, however) */
#cmakedefine SR_HAVE_EACCESS
#ifndef SR_HAVE_EACCESS
#   define eaccess access
#endif

/* name of sysrepo YANG module */
#define SR_YANG_MOD "sysrepo"

/* main sysrepo repository path; prefix of all other paths by default */
#define SR_REPO_PATH "@REPO_PATH@"

/* environment variable overriding the compiled-in value */
#define SR_REPO_PATH_ENV "SYSREPO_REPOSITORY_PATH"

/* if not set, defaults to "SR_REPO_PATH/data" */
#define SR_RUNNING_PATH "@RUNNING_DATA_PATH@"

/* if not set, defaults to "SR_REPO_PATH/data" */
#define SR_STARTUP_PATH "@STARTUP_DATA_PATH@"

/* if not set, defaults to "SR_REPO_PATH/data/notif" */
#define SR_NOTIFICATION_PATH "@NOTIFICATION_PATH@"

/* if not set, defaults to "SR_REPO_PATH/yang" */
#define SR_YANG_PATH "@YANG_MODULE_PATH@"

/* notification file will never exceed this size (kB) */
#define SR_EV_NOTIF_FILE_MAX_SIZE 1024

/* maximum main SHM wasted memory (B) */
#define SR_MAIN_SHM_WASTED_MAX_MEM 4096

/* time slept when wanting a write lock on a module that is already locked (ms) */
#define SR_MOD_WRITE_LOCK_SLEEP 10

/* time a subscriber thread sleeps if no event occurs (ms) */
#define SR_SUB_NOEVENT_SLEEP 50

/* timeout for processing all events on all subscriptions of one subscriber thread; used when modifying subscriptions (s) */
#define SR_SUB_EVENT_LOOP_TIMEOUT 30

/* timeout for locking subscriptions lock, used when modifying subscriptions (ms) */
#define SR_SUB_SUBS_LOCK_TIMEOUT 100

/* timeout for locking main SHM and subscription SHM; maximum time an API call (sr_apply_changes()) is expected to take (s) */
#define SR_MAIN_LOCK_TIMEOUT 15

/* maximum time a lock on a subscription SHM is expected to be held; how long to wait for a write lock (ms) */
#define SR_SUB_LOCK_TIME 1000

/* timeout for locking (data of) a module; maximum time a module write lock is expected to be held (s) */
#define SR_MOD_LOCK_TIMEOUT 2

/* permissions of main SHM lock file and main SHM itself */
#define SR_MAIN_SHM_PERM 00666

/* permissions of all subscription SHMs */
#define SR_SUB_SHM_PERM 00666

/* permissions of directories for sysrepo files */
#define SR_DIR_PERM 00777

/* permissions of used YANG modules */
#define SR_YANG_PERM 00664

/* permissions of stored notifications and data files */
#define SR_FILE_PERM 00600

/*
 * internal declarations + definitions
 */
typedef struct sr_mod_s sr_mod_t;

typedef struct sr_mod_data_dep_s sr_mod_data_dep_t;

typedef struct sr_shm_s {
    int fd;
    size_t size;
    char *addr;
} sr_shm_t;

typedef struct sr_sid_s {
    uint32_t sr;
    uint32_t nc;
    char *user;
} sr_sid_t;

#include "replay.h"
#include "modinfo.h"
#include "edit_diff.h"
#include "shm.h"
#include "log.h"

/*
 * public definitions
 */
struct sr_conn_ctx_s {
    char *app_name;
    struct ly_ctx *ly_ctx;

    /* session-shared lock */
    pthread_mutex_t ptr_lock;
    sr_session_ctx_t **sessions;
    uint32_t session_count;
    sr_subscription_ctx_t **subscriptions;
    uint32_t subscription_count;

    /* process-shared lock */
    int main_shm_create_lock;
    /* session-shared lock */
    pthread_mutex_t main_shm_remap_lock;
    sr_shm_t main_shm;
    uint32_t main_ver;
};

struct sr_session_ctx_s {
    sr_conn_ctx_t *conn;
    sr_datastore_t ds;
    sr_sub_event_t ev;
    sr_sid_t sid;
    uint8_t flags;
    sr_error_info_t *err_info;

    struct {
        struct lyd_node *edit;
        struct lyd_node *diff;
    } dt[2];
};

struct sr_subscription_ctx_s {
    sr_conn_ctx_t *conn;
    volatile pthread_t tid;
    pthread_mutex_t subs_lock;

    struct modsub_conf_s {
        char *module_name;
        sr_datastore_t ds;
        struct modsub_confsub_s {
            char *xpath;
            uint32_t priority;
            sr_subscr_options_t opts;
            sr_module_change_cb cb;
            void *private_data;

            uint32_t event_id;
            sr_sub_event_t event;
        } *subs;
        uint32_t sub_count;

        struct lyd_node *last_change_diff;
        sr_shm_t sub_shm;
    } *conf_subs;
    uint32_t conf_sub_count;

    struct modsub_dp_s {
        char *module_name;
        struct modsub_dpsub_s {
            char *xpath;
            sr_dp_get_items_cb cb;
            void *private_data;

            uint32_t event_id;
            sr_shm_t sub_shm;
        } *subs;
        uint32_t sub_count;
    } *dp_subs;
    uint32_t dp_sub_count;

    struct modsub_rpc_s {
        char *xpath;
        sr_rpc_cb cb;
        sr_rpc_tree_cb tree_cb;
        void *private_data;

        uint32_t event_id;
        sr_shm_t sub_shm;
    } *rpc_subs;
    uint32_t rpc_sub_count;

    struct modsub_notif_s {
        char *module_name;
        struct modsub_notifsub_s {
            char *xpath;
            time_t start_time;
            int replayed;
            time_t stop_time;
            sr_event_notif_cb cb;
            sr_event_notif_tree_cb tree_cb;
            void *private_data;
        } *subs;
        uint32_t sub_count;

        uint32_t event_id;
        sr_shm_t sub_shm;
    } *notif_subs;
    uint32_t notif_sub_count;
};

struct sr_change_iter_s {
    struct ly_set *set;
    uint32_t idx;
    int reverse_changes;
};

/*
 * subscription functions
 */
sr_error_info_t *sr_sub_conf_add(const char *mod_name, const char *xpath, sr_datastore_t ds, sr_module_change_cb conf_cb,
        void *private_data, uint32_t priority, sr_subscr_options_t sub_opts, sr_subscription_ctx_t *subs);

void sr_sub_conf_del(const char *mod_name, const char *xpath, sr_datastore_t ds, sr_module_change_cb conf_cb,
        void *private_data, uint32_t priority, sr_subscr_options_t sub_opts, sr_subscription_ctx_t *subs);

sr_error_info_t *sr_sub_dp_add(const char *mod_name, const char *xpath, sr_dp_get_items_cb dp_cb, void *private_data,
        sr_subscription_ctx_t *subs);

void sr_sub_dp_del(const char *mod_name, const char *xpath, sr_subscription_ctx_t *subs);

sr_error_info_t *sr_sub_rpc_add(const char *mod_name, const char *xpath, sr_rpc_cb rpc_cb, sr_rpc_tree_cb rpc_tree_cb,
        void *private_data, sr_subscription_ctx_t *subs);

void sr_sub_rpc_del(const char *xpath, sr_subscription_ctx_t *subs);

sr_error_info_t *sr_sub_notif_add(const char *mod_name, const char *xpath, time_t start_time, time_t stop_time,
        sr_event_notif_cb callback, sr_event_notif_tree_cb tree_callback, void *private_data, sr_subscription_ctx_t *subs);

void sr_sub_notif_del(const char *mod_name, const char *xpath, time_t start_time, time_t stop_time, sr_event_notif_cb callback,
        sr_event_notif_tree_cb tree_callback, void *private_data, sr_subscription_ctx_t *subs, int has_subs_lock);

sr_error_info_t *sr_subs_del_all(sr_conn_ctx_t *conn, sr_subscription_ctx_t *subs);

sr_error_info_t *sr_notif_find_subscriber(sr_conn_ctx_t *conn, const char *mod_name, uint32_t *notif_sub_count);

sr_error_info_t *sr_notif_call_callback(sr_event_notif_cb cb, sr_event_notif_tree_cb tree_cb, void *private_data,
        const sr_ev_notif_type_t notif_type, const struct lyd_node *notif_op, time_t notif_ts);

/*
 * utility functions
 */
sr_error_info_t *sr_ly_ctx_new(struct ly_ctx **ly_ctx);

sr_error_info_t *sr_create_module_files_with_imps_r(const struct lys_module *mod);

sr_error_info_t *sr_create_module_update_files_with_imps_r(const struct lys_module *mod, int first_upd_module);

sr_error_info_t *sr_path_running_dir(char **path);

sr_error_info_t *sr_path_startup_dir(char **path);

sr_error_info_t *sr_path_notif_dir(char **path);

sr_error_info_t *sr_path_yang_dir(char **path);

sr_error_info_t *sr_path_running_file(const char *mod_name, char **path);

sr_error_info_t *sr_path_startup_file(const char *mod_name, char **path);

sr_error_info_t *sr_path_notif_file(const char *mod_name, time_t from_ts, time_t to_ts, char **path);

sr_error_info_t *sr_path_yang_file(const char *mod_name, const char *mod_rev, int update_prefix, char **path);

sr_error_info_t *sr_get_pwd(uid_t *uid, char **user);

sr_error_info_t *sr_chmodown(const char *path, const char *owner, const char *group, mode_t perm);

sr_error_info_t *sr_perm_check(const char *mod_name, int wr);

sr_error_info_t *sr_perm_get(const char *mod_name, char **owner, char **group, mode_t *perm);

void sr_time_get(struct timespec *ts, uint32_t add_ms);

int sr_time_is_timeout(struct timespec *ts);

/* if new_shm_size == 0 needs READ lock, otherwise needs WRITE lock! */
sr_error_info_t *sr_shm_remap(sr_shm_t *shm, size_t new_shm_size);

void sr_shm_destroy(sr_shm_t *shm);

off_t sr_shmcpy(char *shm_addr, const void *src, size_t size, char **shm_end);

sr_error_info_t *sr_mlock(pthread_mutex_t *lock, int timeout_ms, const char *func);

void sr_munlock(pthread_mutex_t *lock);

sr_error_info_t *sr_rwlock(pthread_rwlock_t *rwlock, int timeout_ms, int wr, const char *func);

void sr_rwunlock(pthread_rwlock_t *rwlock);

void *sr_realloc(void *ptr, size_t size);

sr_error_info_t *sr_cp(const char *to, const char *from);

sr_error_info_t *sr_mkpath(char *path, mode_t mode);

char *sr_get_first_ns(const char *expr);

const char *sr_ds2str(sr_datastore_t ds);

sr_error_info_t *sr_msleep(uint32_t msec);

sr_error_info_t *sr_file_get_size(int fd, size_t *size);

const char *sr_ly_leaf_value_str(const struct lyd_node *leaf);

sr_error_info_t *sr_mutex_init(pthread_mutex_t *lock, int shared);

sr_error_info_t *sr_rwlock_init(pthread_rwlock_t *rwlock, int shared);

sr_error_info_t *sr_cond_init(pthread_cond_t *cond, int shared);

const char *sr_ev2str(sr_sub_event_t ev);

sr_notif_event_t sr_ev2api(sr_sub_event_t ev);

sr_error_info_t *sr_val_ly2sr(const struct lyd_node *node, sr_val_t *sr_val);

/* buf must be size at least 22 */
char *sr_val_sr2ly_str(struct ly_ctx *ctx, const sr_val_t *sr_val, char *buf);

sr_error_info_t *sr_val_sr2ly(struct ly_ctx *ctx, const char *xpath, const char *val_str, int dflt, int output,
        struct lyd_node **root);

void sr_ly_split(struct lyd_node *sibling);

void sr_ly_link(struct lyd_node *first, struct lyd_node *sibling);

int sr_ly_is_userord(const struct lyd_node *node);

sr_error_info_t *sr_ly_data_dup_xpath_select(const struct lyd_node *data, char **xpaths, uint16_t xp_count,
        struct lyd_node **new_data);

sr_error_info_t *sr_ly_data_xpath_complement(struct lyd_node **data, const char *xpath);

uint32_t sr_str_hash(const char *str);

sr_error_info_t *sr_xpath_trim_last_node(const char *xpath, char **trim_xpath, char **last_node_xpath);

char *sr_xpath_first_node(const char *xpath);

size_t sr_xpath_len_no_predicates(const char *xpath);

sr_error_info_t *sr_ly_find_last_parent(struct lyd_node **parent, int nodetype);

#endif
