/**
 * @file common.h
 * @author Michal Vasko <mvasko@cesnet.cz>
 * @brief common routines header
 *
 * @copyright
 * Copyright (c) 2019 CESNET, z.s.p.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef _COMMON_H
#define _COMMON_H

#define _GNU_SOURCE
#define _POSIX_C_SOURCE 200809L

#include <stdint.h>
#include <string.h>
#include <errno.h>

#include <libyang/libyang.h>

#include "sysrepo.h"

/*
 * If the compiler supports attribute to mark objects as hidden, mark all
 * objects as hidden and export only objects explicitly marked to be part of
 * the public API.
 */
#define API __attribute__((visibility("default")))

#define SR_YANG_MOD "sysrepo"
#define SR_REPO_PATH "@REPO_PATH@"
#define SR_REPO_PATH_ENV "SYSREPO_REPOSITORY_PATH"

/* kbs */
#define SR_EV_NOTIF_FILE_MAX_SIZE 1024

/* s */
#define SR_MODULE_LOCK_TIMEOUT 5

/* s */
#define SR_SUBSCR_JOIN_TIMEOUT 5

/* ms */
#define SR_LOCK_TIMEOUT 100

/* ms */
#define SR_SUB_EVENT_STEP_TIMEOUT 20

/* number of */
#define SR_SUB_EVENT_STEP_COUNT 500

/* internal declarations + definitions
 */
typedef struct sr_mod_s sr_mod_t;

typedef struct sr_mod_data_dep_s sr_mod_data_dep_t;

typedef struct sr_shm_s {
    int fd;
    size_t size;
    char *addr;
} sr_shm_t;

typedef struct sr_sid_s {
    uint32_t sr;
    uint32_t nc;
} sr_sid_t;

#include "replay.h"
#include "modinfo.h"
#include "edit_diff.h"
#include "shm.h"
#include "log.h"

/*
 * public definitions
 */
struct sr_conn_ctx_s {
    char *app_name;
    struct ly_ctx *ly_ctx;

    pthread_mutex_t ptr_lock;
    sr_session_ctx_t **sessions;
    uint32_t session_count;
    sr_subscription_ctx_t **subscriptions;
    uint32_t subscription_count;

    int main_plock;
    pthread_rwlock_t main_tlock;
    uint32_t main_ver;
    sr_shm_t main_shm;
};

struct sr_session_ctx_s {
    sr_conn_ctx_t *conn;
    sr_datastore_t ds;
    sr_notif_event_t ev;
    sr_sid_t sid;
    uint8_t flags;
    sr_error_info_t *err_info;

    struct {
        struct lyd_node *edit;
        struct lyd_node *diff;
    } dt[2];
};

struct sr_subscription_ctx_s {
    sr_conn_ctx_t *conn;
    volatile pthread_t tid;
    pthread_mutex_t subs_lock;

    struct modsub_conf_s {
        char *module_name;
        sr_datastore_t ds;
        struct modsub_confsub_s {
            char *xpath;
            uint32_t priority;
            sr_subscr_options_t opts;
            sr_module_change_cb cb;
            void *private_data;

            uint32_t event_id;
            sr_notif_event_t event;
        } *subs;
        uint32_t sub_count;

        struct lyd_node *last_change_diff;
        sr_shm_t sub_shm;
    } *conf_subs;
    uint32_t conf_sub_count;

    struct modsub_dp_s {
        char *module_name;
        struct modsub_dpsub_s {
            char *xpath;
            sr_dp_get_items_cb cb;
            void *private_data;

            uint32_t event_id;
            sr_shm_t sub_shm;
        } *subs;
        uint32_t sub_count;
    } *dp_subs;
    uint32_t dp_sub_count;

    struct modsub_rpc_s {
        char *xpath;
        sr_rpc_cb cb;
        sr_rpc_tree_cb tree_cb;
        void *private_data;

        uint32_t event_id;
        sr_shm_t sub_shm;
    } *rpc_subs;
    uint32_t rpc_sub_count;

    struct modsub_notif_s {
        char *module_name;
        struct modsub_notifsub_s {
            char *xpath;
            time_t start_time;
            int replayed;
            time_t stop_time;
            sr_event_notif_cb cb;
            sr_event_notif_tree_cb tree_cb;
            void *private_data;
        } *subs;
        uint32_t sub_count;

        uint32_t event_id;
        sr_shm_t sub_shm;
    } *notif_subs;
    uint32_t notif_sub_count;
};

struct sr_change_iter_s {
    struct ly_set *set;
    uint32_t idx;
    int reverse_changes;
};

/*
 * subscription functions
 */
sr_error_info_t *sr_sub_conf_add(const char *mod_name, const char *xpath, sr_datastore_t ds, sr_module_change_cb conf_cb,
        void *private_data, uint32_t priority, sr_subscr_options_t sub_opts, sr_subscription_ctx_t *subs);

void sr_sub_conf_del(const char *mod_name, const char *xpath, sr_datastore_t ds, sr_module_change_cb conf_cb,
        void *private_data, uint32_t priority, sr_subscr_options_t sub_opts, sr_subscription_ctx_t *subs);

sr_error_info_t *sr_sub_dp_add(const char *mod_name, const char *xpath, sr_dp_get_items_cb dp_cb, void *private_data,
        sr_subscription_ctx_t *subs);

void sr_sub_dp_del(const char *mod_name, const char *xpath, sr_subscription_ctx_t *subs);

sr_error_info_t *sr_sub_rpc_add(const char *mod_name, const char *xpath, sr_rpc_cb rpc_cb, sr_rpc_tree_cb rpc_tree_cb,
        void *private_data, sr_subscription_ctx_t *subs);

void sr_sub_rpc_del(const char *xpath, sr_subscription_ctx_t *subs);

sr_error_info_t *sr_sub_notif_add(const char *mod_name, const char *xpath, time_t start_time, time_t stop_time,
        sr_event_notif_cb callback, sr_event_notif_tree_cb tree_callback, void *private_data, sr_subscription_ctx_t *subs);

void sr_sub_notif_del(const char *mod_name, const char *xpath, time_t start_time, time_t stop_time, sr_event_notif_cb callback,
        sr_event_notif_tree_cb tree_callback, void *private_data, sr_subscription_ctx_t *subs, int has_subs_lock);

sr_error_info_t *sr_subs_del_all(sr_conn_ctx_t *conn, sr_subscription_ctx_t *subs);

sr_error_info_t *sr_notif_call_callback(sr_event_notif_cb cb, sr_event_notif_tree_cb tree_cb, void *private_data,
        const sr_ev_notif_type_t notif_type, const struct lyd_node *notif_op, time_t notif_ts);

/*
 * utility functions
 */
/* if new_shm_size == 0 needs READ lock, otherwise needs WRITE lock! */
sr_error_info_t *sr_shm_remap(sr_shm_t *shm, size_t new_shm_size);

void sr_shm_destroy(sr_shm_t *shm);

sr_error_info_t *sr_mlock(pthread_mutex_t *lock, const char *func);

void sr_munlock(pthread_mutex_t *lock);

sr_error_info_t *sr_rwlock(pthread_rwlock_t *rwlock, int wr, const char *func);

void sr_rwunlock(pthread_rwlock_t *rwlock);

void *sr_realloc(void *ptr, size_t size);

sr_error_info_t *sr_cp(const char *to, const char *from);

sr_error_info_t *sr_mkpath(char *file_path, mode_t mode, uint32_t start_idx);

char *sr_get_first_ns(const char *expr);

const char *sr_ds2str(sr_datastore_t ds);

sr_error_info_t *sr_msleep(uint32_t msec);

sr_error_info_t *sr_file_get_size(int fd, size_t *size);

const char *sr_ly_leaf_value_str(const struct lyd_node *leaf);

sr_error_info_t *sr_shared_rwlock_init(pthread_rwlock_t *rwlock);

const char *sr_ev2str(sr_notif_event_t ev);

sr_error_info_t *sr_val_ly2sr(const struct lyd_node *node, sr_val_t *sr_val);

/* buf must be size at least 22 */
char *sr_val_sr2ly_str(struct ly_ctx *ctx, const sr_val_t *sr_val, char *buf);

sr_error_info_t *sr_val_sr2ly(struct ly_ctx *ctx, const char *xpath, const char *val_str, int dflt, int output,
        struct lyd_node **root);

void sr_ly_split(struct lyd_node *sibling);

void sr_ly_link(struct lyd_node *first, struct lyd_node *sibling);

int sr_ly_is_userord(const struct lyd_node *node);

sr_error_info_t *sr_ly_data_dup_xpath_select(const struct lyd_node *data, char **xpaths, uint16_t xp_count,
        struct lyd_node **new_data);

sr_error_info_t *sr_ly_data_xpath_complement(struct lyd_node **data, const char *xpath);

uint32_t sr_str_hash(const char *str);

sr_error_info_t *sr_xpath_trim_last_node(const char *xpath, char **trim_xpath, char **last_node_xpath);

char *sr_xpath_first_node(const char *xpath);

size_t sr_xpath_len_no_predicates(const char *xpath);

sr_error_info_t *sr_ly_find_last_parent(struct lyd_node **parent, int nodetype);

#endif
